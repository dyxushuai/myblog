前面聊了一下[api设计的耗时处理](https://github.com/jwongzblog/myblog/blob/master/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%B5%85%E8%B0%88api%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%80%97%E6%97%B6%E5%9B%A0%E7%B4%A0.md)，大多数openapi的设计只能切片，或者说所有。但是没有绝对完美的方案，具体还是要根据产品的场景来设计程序的交互。这篇浅谈利用异步的方式来处理耗时的操作。

请注意，**异步会导致乱序，而乱序的结果是程序的行为控制会变得复杂**

作为程序员最喜欢写的代码是顺序代码（或者说是**同步**），我调一个函数或者一个api，你给我一个结果，我再根据这个结果决定程序下一步该怎么走。然而**理想丰满，现实骨干**，这个函数或者远程调用的耗时往往最难处理。举个浅显的例子，你们在使用app、桌面应用，或者浏览器访问网页的时候，最**烂**的用户体验是什么，我认为是一种**卡死**状态，遇到这种体验我有种咂手机或者扔鼠标的**焦躁**。这个锅不能产品经理背，必须是程序员背，这是判断架构师或者程序员能力的条件之一。

**网络一定是不可靠的，网络一定是有延迟的**，基于这个共识，架构师、程序员才能时刻考虑这样的背景下，怎么设计才能让程序成功。

我曾经碰到一个**案例**，可以分享一下
*我曾经负责的一个C/S架构模型的软件服务端设计与实现，我设计并实现了一整套私有协议下的RPC接口供Windows客户端调用，桌面端的同事说：你的协议解析太复杂，struct太多了，你封装成SDK给我调，我要什么结果你就组合成SDK吧。我觉得有道理，于是我又把RPC全部组合成可直接调用的功能函数，而且当时也考虑了超时，利用ACE框架的Wait类实现了超时处理*

“9 10 6”搞3个月后，一个同步的SDK在1000人以下的局域网完美运行。直到产品开卖，老板拍板的**用户绝对不超过500人**的承诺成为过去。于是部门接受的抱怨最多的就是怎么老卡死，桌面端的程序员摔锅说：SDK是阻塞的，我也没办法。以我当时的阅历觉得很有道理，而且我也无能为力，因为代码完成后几乎没出现过BUG，服务器响应慢也没办法，因为后端服务为了**避免请求乱序导致所有交互逻辑不可逆的错误**，被设计成了阻塞的，顺序执行的单进程，单线程。**请注意本段文字加粗的前提条件**。事实证明，服务端设计为了避免乱序过于简单粗暴，这符合“**二八原则**”，就是为了解决这20%的乱序问题，我需要花费80%的时间和精力去解决，然而我已经一个人，断断续续3个月的**“9 10 6”**。

我再强调一下，**顺序执行的代码不仅可读性好，而且BUG很少**

回首往事，上面那个失败的案例其实有很多的优化手段
* 单进程不符合松耦合的设计，我们需要按功能划分服务，这样依赖需要顺序执行的代码可以单独处理，而且这类单独处理的手段也可以多样，比如利用简化的paxos算法让请求加上时间顺序，这样一来可以确保服务器最终一致性；另外可以梳理出需要顺序执行的原子部分，使用分布式全局锁来解决
* 虽然我的SDK是同步的，但其实客户端的框架是可以在SDK上层实现**异步调用**的，尽管异步处理起来很难，以当时c++ 98的语法，要实现异步需要利用多线程，而多线程处理对于一个任何段位的程序员来讲都很复杂，**c++11出现了async，其实也是基于多线程加了一些语法糖（sugar），缩小了代码量，但任然不完美，因为一旦调用获取线程的状态，逻辑就阻塞了，需要等待get()调用结束，只是延迟了等待的时机，并不是基于事件驱动**。我能理解这位客户端程序员，但**这个锅我不能全背**
* 利用订阅发布者模型实现异步，这个其实我和客户端讨论过，当时是说调我的RPC全部立即结束，另外起进程监听服务端发过来的消息，再继续处理逻辑，但是这样**逻辑就相当复杂**了，需要客户端有个缓存来处理状态，sqlite是个不错的选择，最终我们选择了封装SDK。但我觉得订阅发布者模型是最适合多client端的场景。最佳实践移步至这里《[openstack模式设计-消息中间件](https://github.com/jwongzblog/myblog/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/openstack%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6.md)》，不过openstack的数据类型（struct）很少，逻辑不复杂，只需要处理个位数的状态同步
