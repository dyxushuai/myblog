首先要区分并发和并行的概念，两者完全不是同一样东西

并发的坑：
对公共变量的操作的安全性问题
- 原子性，glib有atomic变量，++、--无忧，但是真实的代码世界哪有这么简单的类型，所以我们写并发代码或者选择第三方开源包时，需要确认哪些上下文或者范围需要是原子的。
- 不加锁就乱
- 一旦加锁则废，锁会让并发变成串行
- 死锁，相互等待，饿死，通常由于一些异常或者goto让程序的执行顺序错乱，导致unlock，或者出现相互占用一个锁没释放，但又相互等待对方的锁
