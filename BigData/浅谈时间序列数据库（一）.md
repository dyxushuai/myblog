*没有银弹*---by《人月神话》

当一项新技术被吹捧时，我们应该学习它的创新点，并将它应用到合适的地方。**没有银弹**告诉我们，并没有一个完美的方案可以解决所有问题，好比天枰的两端，只有取舍后的相对平衡

最近在选型监控系统的后端存储，借此机会聊聊预研的几款时序数据库。原先我们使用mongoDB作为监控系统的数据存储，经过一段时间后，我们发现如下问题：
* 数据未被压缩，磁盘空间线性增长
* 数据读写性能下降
* 查询速度下降，导致浏览器绘图加载时间过长，影响使用
* 换成SSD后缓解了一点，但是成本过高

监控数据如同IoT、用户行为分析、工业大数据等领域系统一样，是一类基于时间纬度的数据，业界为此专门开发了一系列的时序数据库，它具备如下特点：
* 写入平稳、持续、高并发高吞吐
* 写多读少
* 实时写入最近生成的数据，无更新
* 按时间范围读取、多精度查询
* 多维分析、多精度查询
* 数据挖掘
* 数据量大、冷热分明、具有时效性
* 高并发、海量存储
* 交互级的聚合查询

上面的特点看起来很心动吧，可是没有一款时序数据库完整的实现了所有特性。有的在现有BigTable型数据库上封装了一层时序数据库的特性，如[kairosDB](http://kairosdb.github.io/)；有的推倒重来，尝试满足小型数据量，如[influxDB](https://docs.influxdata.com/)，麻雀虽小五脏俱全；还有的提供极致的写入、查询速度，极致的压缩率，如facebook开源的[beringei](https://yq.aliyun.com/articles/72871)。为什么市面上有如此之多的时序数据库？还是那句话，“没有银弹”。

在业务量小的时候，怎么捣鼓都行。但是业务量一大，很多问题就冒出来了。对于应用层开发者来讲，我不管你底层设计多么优秀，你至少保证我两点：
* 发过来的数据能够即时写入，不丢，也不阻塞我的调用
* 找你要数据时，你能在100毫秒以内反馈数据

第一点好解决，系统设计成分布式的，auto-scale提高并行能力即可，第二点最难，因为一个查询请求通常是串行的，如果要提高查询速度，就要求数据库系统内部把串行过程中能改成并行就改成并行，而并行是所有人的噩梦。所以时序数据库有两个非常惊艳的功能：
* 自动降精度（auto-rollup），把毫秒级间隔的时间event降到15分钟、30分钟，甚至更长的时间间隔
* 预聚合（auto-aggregation），比如在查询之前，TSDB就把过去一年的数据以30分钟间隔算出均值重新写入新的tag，查询时直接取结果。节省查询时间和数据传输量。

这个两个功能不算创新，我起个定时任务也能处理，但是目前为止我还没有看到哪个时序数据库是把这两个功能处理的很好的，说来话长，此处又可以独立成篇了......

[下一篇](https://github.com/jwongzblog/myblog/blob/master/BigData/%E6%B5%85%E8%B0%88%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89.md)：[《浅谈时间序列数据库（二）》](https://github.com/jwongzblog/myblog/blob/master/BigData/%E6%B5%85%E8%B0%88%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89.md)

参考：

《[时间序列数据的存储和计算](https://yq.aliyun.com/articles/72871)》 ---by 木洛

《[Gorilla：一种快速、可扩展的内存时间序列数据库](https://yq.aliyun.com/articles/72871)》---by facebook

《[技术解读：Facebook开源内存数据库Beringei，如何做到极致的压缩率](http://www.sohu.com/a/132151905_256833)》--- by EGOnetwork
