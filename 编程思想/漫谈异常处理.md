```
无知者无畏.
             ----孔子【鲁】
```
计算机体系设计的模式是分层，从我们的上层应用到流（stream），最后到CPU、01、电流开关，除了无限不循环小数无法处理，它能处理有限精度的任务，每个分层解决自己需要面对的问题，最后都分解成0、1的计算，我们的设计脱离不了图灵机的原型。但是对面层次丰富的复杂软件系统，我觉得异常处理是一个挑战，一言难尽，此篇简单聊聊异常处理，如有新的认知会持续更新

我暂时分成四大类讨论，分别是**资源释放型、数据一致型、状态复原型、错误分析**

# 资源释放型
- 内存泄露
说c++很强大的人，很重要的一点是觉得可以自由操纵内存，追求极致的内存占用问题，玩C语言的就不乐意了，说你的虚指针还在那搁着了，其实作为常驻进程，内存的释放时机需要做很多文章*（参见effective c++<第三版>，第7、8、9、16、17条）*一不留神就会出现内存泄露的风险，哪怕使用智能指针，也有内存泄露的风险*（参见effective c++<第三版>，第17条）*，对于业务型团队而言，c++的心智负担太重了，时效性价比不高。新出现的语言基本上都自带gc(内存回收)，业务层基本上抢掉了c++的饭碗，而系统层，rust正在蚕食c++的市场（像TiDB的存储引擎使用rust）
- python:with
overload基类的析构函数，在析构函数里释放资源，这样一来使用with语法，会在作用域退出时调用析构函数去释放资源
```
with open('a.txt') as f:
    print f.readlines()
```
- go:defer
go语言的这个关键字达到的效果和python:with一样，好东西那是一定要copy上的
- 非编程语言层面的资源释放
软件是分层的，我们不需要重复造轮子，很多时候我们都需要依赖更低层次的封装，但是由于网络抖动或者服务器故障这些不可抗力的因素，我们要认定百分百会故障的情况下，我们的程序该如何正确的运行。
比如程序原本想对SAN存储进行快照、挂载、备份挂载卷的操作，结果一系列资源初始化完成后，一个请求timeout了，那么对方有没有接受到这个请求？如果接受到了请求，有没有处理成功？我重复三次请求，对方依然没有响应怎么办？我的程序是速错*（fail fast， 参考至《[面对软件错误构建可靠的分布式系统](http://www.docin.com/p-7336786.html)》）*？还是构造成对的new/delete操作将资源释放掉
```
to be or not to be that is a question.
                                   ---- Shakespeare <Hamlet>
```
- dead lock

# 状态复原型
- database transaction事务处理
关系型数据库都提供了事务处理，中间出现错误，可以将数据库恢复至transaction最初状态，确保这一系列的操作是原子的，但是架构师在处理web框架时，一定要弹性设计一个web请求的入口和出口，既允许程序员在web请求退出时无脑orm.commit()，也需要允许web请求退出前多次commit以保留状态
- 分布式事务
要求所有参与该事务的服务器全部提交或者全部放弃，遵循2PC*（两阶段提交协议，《分布式系统概念与设计》）*

# 数据一致型
- 对象文件系统
举一个例子，老同事刘浩分享的用户数据丢失的事故分析，文件落盘和元数据记录的先后顺序也有影响：基础架构部提供了一套c++封装的对象存储接口，用户数据丢失后发现服务器端，该文件的元数据还在，但是文件没了......review代码后发现基础架构部的实现逻辑是这样的：
**服务器接收到存储文件的请求->记录文件的元数据->启动进程将stream写入磁盘->return null**
在没有任何异常的情况下，逻辑毫无问题，关键是stream写入磁盘的逻辑出现异常了，但是前面那个记录元数据的步骤没回滚，也就是这个操作不是原子的，不是事务的，最终导致客户端误以为文件存储成功，但实际上没有数据
*对于写这段代码的人而言也许是个代码顺序的问题，也许是架构师并没有引入事务机制*
- 缓存与数据库
有个前同事问了我一个问题，他说他们的架构师用redis作为客户端与数据库之间的缓存层，经常出现缓存与数据库不同步的问题，不知道怎么排查。这个问题我也没法回答，我没有足够日志和debug信息去排查问题，但是缓存的操作要确保几个原则：
**1.确保缓存和数据库操作是原子的、事务的**
**2.确保非幂等（create\put\delete）的操作缓存和数据库的入口只有一个**
**3.确保缓存数据的分区容错性，如果不能，可以尝试找到标记缓存层和数据库层的方法，定期检查状态并同步**
**4.加锁，这上升到进程同步的问题了**

- CAP
谈分布式系统时绕不开的话题，ceph三副本操作时允许设置策略来平衡IOPS与数据一致性，即其中两副本必须写成功再返回写入成功，剩余的一个副本可以慢慢同步
- ceph scrub
可以启动定时扫描系统的一致性，确保各个副本的元数据与数据是一致的，属于一种监控、修复机制
- [paxos](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650994727&idx=1&sn=913e3123bf4cc4885ce3c15bce6b7adc&chksm=bdbf00748ac88962f607394bd8af8e73182a9b011443bf2e99c9ae07372cd59ad305ec5910f8&mpshare=1&scene=1&srcid=0727dG3LogSKnZ0SvcQ1lu2a#rd)
比CAP更高级的分布式数据一致性算法思想，有点像2PC的加强版

# 错误诊断
- log
在线运行的系统没有log，估计公司不倒很难
- 错误码
[windows错误码设计](http://www.cnblogs.com/hbccdf/p/windows_error_code_parsing.html)了解一下，十六进制的错误码基本能定位到哪个模块出问题了，后端服务可以参照此设计，弱化错误的description，让client端比较自由的处理错误码对应的行为
- actor
在erlang之父的博士论文里(《[面对软件错误构建可靠的分布式系统](http://www.docin.com/p-7336786.html)》)提出了一种异常处理方式，他把我泛指的异常分成三类：
**1.错误，有案可查的被定义类型**
**2.异常，无法预判的错误，比如编译器抛出来的异常**
**3.故障，尝试修复异常，或者无法修复异常，任由无法预判的异常蔓延，影响周围的进程和系统**
他认为第一类错误是程序员理应处理的，而第二类异常就需要速错，然后任由进程崩溃，在交给监督进程处理错误信息，重新拉起来新进程，避免进一步上升到第三类故障型，模块需要拆分得足够小，确保进程崩溃不互相影响。
**在处理异常时，Joe坚决抵制防御式编程，因为容易掩盖程序异常的真实原因**
```
#python
try:
    ....
except:
    throw except("unkown") 
```
程序员为了防止遗漏未知的异常类型，而使用except去捕获异常，最后抛出一个unkown，我估计任何处理上层代码的程序员或者客户，都会懵逼的吧，维护这段代码的人也会有理由说是为了防止进程崩溃啊
erlang的OPT是专门为了实现actor模式而诞生，整体设计是逻辑自洽的，其他语言如果任其崩溃，那就真崩溃了~~单单靠keepalive去拉起来，这些弱并发、弱并行的语言和框架只怕还有很多问题难以解决
